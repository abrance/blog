<html>
<head>
  <title>Evernote Export</title>
  <basefont face="Consolas" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602498 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: Consolas;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="3653"/>
<h1>random</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2020/12/9 10:26</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2020/12/9 10:27</i></td></tr>
<tr><td><b>作者：</b></td><td><i>DaguguJ</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 204px;"></col><col style="width: 950px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 204px; padding: 8px;"><div>参考</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 950px; padding: 8px;"><ul><li><div><a href="https://zhuanlan.zhihu.com/p/160766043">https://zhuanlan.zhihu.com/p/160766043</a></div></li><li><div><a href="https://blog.csdn.net/laing92/article/details/104229305">https://blog.csdn.net/laing92/article/details/104229305</a></div></li><li><div><a href="https://www.cnblogs.com/block2016/p/5601921.html">https://www.cnblogs.com/block2016/p/5601921.html</a></div></li></ul></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 204px; padding: 8px;"><div>随机数</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 950px; padding: 8px;"><div><br/></div><ul><li><div>WHY</div></li><ul><li><div>生成密钥</div></li><ul><li><div>用于对称密码和消息认证码</div></li></ul><li><div>生成公钥密码</div></li><ul><li><div>用于生成公钥密码和数字签名</div></li></ul><li><div>生成初始化向量 IV</div></li><ul><li><div>用于分组密码中的 CBC、CFB、OFB 模式</div></li></ul><li><div>生成 nonce</div></li><ul><li><div>用于防御重放攻击和分组密码中的 CTR 模式</div></li></ul><li><div>生成盐</div></li><ul><li><div>用于基于口令密码的 PBE 等</div></li></ul></ul><li><div>HOW</div></li><ul><li><div>计算机的存储空间都是确定的，只能使用 f(*args) 作为 随机数生成器，随机数生成器使得加密者与接收者不需要再事先共享整个随机位移序列，而只需要共享相对较短的随机种子，然后在需要时把它扩展成相同的看起来很随机的序列就可以</div></li></ul><li><div>WHAT</div></li><ul><li><div>随机数是专门的随机试验的结果</div></li></ul><li><div>随机数的性质与分级</div></li><ul><li><div>随机性</div></li><ul><li><div>分布均匀性和独立性</div></li><ul><li><div>分布均匀性指的是0和1出现的概率大致相等</div></li><li><div>独立性指的是序列中任何子序列不能由其他子序列推导出（不可证明，只能统计学证明）</div></li></ul><li><div>满足这一条即为 弱伪随机数 不可用于密码技术</div></li></ul><li><div>不可预测性 —— 不能从过去的数列推测出下一个出现的数</div></li><ul><li><div>前向不可预测性：不知道种子情况下，不管知道序列多少位，都无法预测下一位。</div></li><li><div>后向不可预测性：从产生的任何值都不能推断出种子值。即种子和该种子产生的任意值之间没有相关性</div></li><li><div>加上随机性即为 强伪随机数 可用于密码技术</div></li></ul><li><div>不可重现性 —— 除非将数列本身保存下来，否则不能重现相同的数列</div></li><ul><li><div>这个序列不能重复产生，即使在完全相同的操作条件下用完全相同的输入对序列发生器操作两次，也将得到两个完全不同的、毫不相关的位序列</div></li><li><div>加上上两条即为 真随机性 可用于密码技术</div></li></ul></ul><li><div>种子</div></li><ul><li><div>f(*args)中的 args，外界取的参数，密码，热噪声，衰变，等真随机数（..有的不是）</div></li><li><div>种子的要求</div></li><ul><li><div>为了达到种子不可预测的目的，通常使用TRNG（真随机数生成器 与 PRNG相对）来产生种子</div></li></ul><li><div>不直接用TRNG的原因</div></li><ul><li><div>TRNG无法产生任意长度的随机数位流</div></li><li><div>TRNG可能会产生不平衡的二元序列，随机化效果不好(比如衰变值总是趋于某较小值)，因此即使是有限数量的位，也是用TRNG产生种子给PRT来产生伪随机位串。</div></li></ul></ul><li><div>定理</div></li><ul><li><div>算法不增熵</div></li><ul><li><div>任何算法（包括那些符合密码学规范的伪随机数算法）只能是“维持”熵、甚至有可能会“降低”熵，但一定不能“增加”熵！记住这一点至关重要，历史上发生过的无数次随机数问题基本上都源于对这一点的忽视，我们暂且命名为“算法不增熵”定理</div></li></ul></ul><li><div>经典算法</div></li><ul><li><div>评判标准</div></li><ul><li><div>种子一定的情况下，序列最终会变成循环序列，较短的序列，生成较长的循环程度则为优。</div></li></ul><li><div>平方取中法</div></li><li><div>线性同余法</div></li><li><div>梅森旋转法</div></li><ul><li><div>一个常用的实现是产生 32 位数字，循环长度 2^19937</div></li></ul></ul></ul></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 204px; padding: 8px;"><div>区块链与随机数</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 950px; padding: 8px;"><ul><li><div>全部引用</div></li><ul><li><div>随机数对于区块链技术来说很关键。本质上，分布式账本的核心问题就是随机选择出块人的问题，这个随机性要能被全网确认，并且不能被操控，也不能被预测，否则恶意节点通过操控这个随机数就可以操控长链，从而实现双花攻击。</div></li><li><div>PoW 的方案是让大家进行算力竞赛，设置一个计算哈希的难题，谁先算出来谁赢，算力高的赢的概率高，算力低的赢的概率低，以这样的方式保证胜出者是随机的。投入的算力能够体现在哈希值上，这样全网能够验证，并选择包含最多算力的那条链。恶意节点只能通过提升自己的算力来增加攻击成功的概率。</div></li><li><div>PoS 的方案是选举，大家不用浪费电力去进行算力竞赛，而是文明一点，随机选举一个节点来出块，并且被选中的概率和它拥有的份额相关。如果“随机”这一步没有问题的话，恶意节点只能通过增加自己的份额，增加自己被选中的概率，从而增加双花攻击的成功概率。这里有一点比 PoW 的方案要好就是，要实现攻击，先得成为持币大户，如果攻击成功币价大跌，攻击者也会承受最大的损失。而 PoW 方案中虽然算力要花钱，但是如果攻击者没有持币，那么他的利益和币价不一定是正相关的，不能排除仍然存在攻击的动力。</div></li><li><div>那么接下来的核心问题就是，这个不能被操控不能被预测的随机数从哪来。</div></li><li><div>传统地 PoS 方案尝试从链上现有的数据入手，比如使用上一个区块的哈希值，上一个区块的时间戳等等来作为随机数的来源，但这些会带来额外的安全风险。因为区块本身的信息就是节点写进去的，然后又要根据里面的信息来选举后续的出块者，存在循环论证的嫌疑，安全性不会太好。这也是传统地认为 PoS 方案不如 PoW 可靠的部分原因。</div></li></ul><li><div>问题</div></li><ul><li><div>知道 交易被发送的矿工 如何攻击导致异常？</div></li></ul></ul></td></tr></tbody></table><div><br/></div></div></span>
</div></body></html> 