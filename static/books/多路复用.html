<html>
<head>
  <title>abrance 多路复用</title>
  <basefont face="Consolas" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602326 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: Consolas;
      font-size: 10pt;
    }
  </style>
</head>
<script type="text/javascript" src="https://cdn.bootcdn.net/ajax/libs/jquery/1.11.3/jquery.js"></script><script> $(function () {console.log($("a").attr("target", "_blank"));})</script>
<body>
<a name="3476"/>
<h1>多路复用</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2020/11/12 13:52</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2020/11/12 14:13</i></td></tr>
<tr><td><b>作者：</b></td><td><i>DaguguJ</i></td></tr>
<tr><td><b>标签：</b></td><td><i>网络应用</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 204px;"></col><col style="width: 950px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 204px; padding: 8px;"><div><br/></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 950px; padding: 8px;"><ul><li><div>解决什么问题：</div></li><ul><li><div>做到资源的最大利用： 加入了一个中间层来管理 连接，而不是每个socket马上起一个线程连接（python httpsever就是这么干的）。</div></li></ul></ul></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 204px; padding: 8px;"><div>参考链接</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 950px; padding: 8px;"><ul><li><div>https://www.cnblogs.com/Anker/p/3265058.html</div></li><li><div>https://baike.baidu.com/item/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/1180849</div></li></ul></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 204px; padding: 8px;"><div>多路复用</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 950px; padding: 8px;"><ul><li><div>定义： 数据通信系统或计算机网络系统中，传输媒体的带宽或容量往往会大于传输单一信号的需求，为了有效地利用通信线路,<span style="color: rgb(255, 0, 0);">希望一个信道同时传输多路信号</span>，这就是所谓的多路复用技术。</div></li><li><div>所以，多路指多路的信号，复用指信道的复用。在 网络io 多路复用中，多路指 多个socket，复用指，一个程序（线程）的复用</div></li></ul></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 204px; padding: 8px;"><div>网络io 多路复用</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 950px; padding: 8px;"><ul><li><div>IO多路复用在Linux下包括了三种，select、poll、epoll，抽象来看，他们功能是类似的，但具体细节各有不同：首先都会对一组文件描述符进行相关事件的注册，然后阻塞等待某些事件的发生或等待超时。IO多路复用都可以关注多个文件描述符，但对于这三种机制而言，不同数量级文件描述符对性能的影响是不同的。</div></li><li><div>I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，<span style="color: rgb(255, 0, 0);">异步I/O的实现会负责把数据从内核拷贝到用户空间</span>。</div></li></ul></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 204px; padding: 8px;"><div>select</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 950px; padding: 8px;"><ul><li><div>（1）使用copy_from_user从用户空间拷贝fd_set到内核空间</div></li><li><div>（2）注册回调函数__pollwait</div></li><li><div>（3）遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）</div></li><li><div>（4）以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。</div></li><li><div>（5）__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。</div></li><li><div>（6）poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。</div></li><li><div>（7）如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。</div></li><li><div>（8）把fd_set从内核空间拷贝到用户空间。</div></li><li><div><br/></div></li><li><div>select的几大缺点：</div></li><li><div>（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</div></li><li><div>（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</div></li><li><div>（3）select支持的文件描述符数量太小了，默认是1024</div></li></ul></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 204px; padding: 8px;"><div>poll</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 950px; padding: 8px;"><ul><li><div>poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构，其他的都差不多。</div></li></ul></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 204px; padding: 8px;"><div>epoll</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 950px; padding: 8px;"><ul><li><div>epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。</div></li><li><div>解决：</div></li><ul><li><div>在此之前，我们先看一下epoll和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。</div></li><li><div><br/></div></li><li><div>对于第一个缺点</div></li><ul><li><div>epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。</div></li></ul><li><div>对于第二个缺点</div></li><ul><li><div>epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并<span style="color: rgb(255, 0, 0);">为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表</span>）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。</div></li></ul><li><div>对于第三个缺点</div></li><ul><li><div>epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。</div></li></ul></ul></ul></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 204px; padding: 8px;"><div><br/></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 950px; padding: 8px;"><div><br/></div></td></tr></tbody></table><div><br/></div></div><div><br/></div></span>
</div></body></html> 